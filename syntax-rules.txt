Pomo: 1:10 --> 1:35
Goal: Get through syntax-rules macros

Set working music on youtube
Transfered pomo tab to current screen

Patterns

(unless condition exp ...)
(my-or exp)

Pattern is structured like the expression that it is to match
Can have nested structure as well, like (let ((var val)...) exp exp* ...)

Turned on noise cancelling and went to more upbeat music

Broadly speaking, patterns are made of lists, improper lists, vectors, identifiers, and datums
Users can match a sequence of patterns using the ellpsis (...)

Identifiers in a pattern are called literals if they are present in the syntax-rules literals list, and pattern vars otherwise

if (in syntax-rules literals list) 
 then (called literals)
 else (called pattern variables)

When building up the macro output, the expander replaces instances of a pattern variable in the template with the matched subexpression

(define-syntax kwote
  (syntax-rules ()
    ((kwote exp)
     (quote exp))))
(kwote (foo . bar))

(define-sytanx let1
  (syntax-rules ()
    ((_ (var val) . exps)
     (let ((var val)) . exps))))

Kind of difficult to learn how this is doing the pattern matching without more examples
Just look at inputs/outputs of other examples and see if anything pops out

Seeing begin in a bunch of examples
 What is begin?

Say I want to increment variable y every time that I use it

(+ x 
   (begin (set! y (+ y 1)) y) 
   z)

The regular (set! x y) does not return a value
This is the reason to use begin -- returns the value of the last arg
So in this case would return the modified y

begin is normally used when there is some side-effect

          (define x 0)
          (begin (set! x 5)
                 (+ x 1))                 =>  6

Often use of begin is unnecssary bceause many special forms already support sequence of expressions (have an implicit begin)
Eg
 case, cond, define, do fluid-let, lambda, let, let*, letrec, named-lambda
The obsolete special form sequence is identica to begin. It should not be used in new code.

begin special form used to evaluate expressions in a particular order
 begin expression expression ...

_________________

Start by writing a simple macro: while
This will be just a standard looping construct that keeps executing over and over until the condition becomes false

Want usage to be like this:

(define x 0)
(while (< x 5) (set! x (+ x 1)) (print x))

(define-syntax while <syntax transformer>)

(define-syntax while 
  (syntax-rules (<keywords>)
    ((<pattern>) <template>)
    ...
    ((<pattern>) <template>)))

Right now we want to match (while condition body ...)
'...' signified that the body may contain one or more forms
This is exactly the sytnax that syntax-reuls wants to see, so we can just plug it in

(define-syntax while
  (syntax-rules ()
    ((while condition body ...) <template>)))

Now want suitable template
Want output to look like

(let loop () 
  (if condition
    (begin
      body ...
      (loop))
    #f))

Now have to put this into our syntax-rules macro as a template
This happens to be exactly like what the template code is expected to look like. Just plug in that code and our final result is:

(define-syntax while1
  (syntax-rules ()
    ((while condition body ...) 
     (let loop () (if condition (begin body ... (loop)) #f)))))

Now let's write something a bit more complicated
Actually first make sure can do the last thing on my own

Why am I tired -- I am drinking coffee
 maybe just need to go for a walk
 maybe what I am doing is a bit boring
  unsure -- take a walk and power through

Now try something a bit more complicated
Try to do a for loop

Goal is to write:
(for <element> in <list>
     <body ...>)

And have it expand to 

(for-each (lambda (<element>) <body ...>) <list>)

(define-syntax for1
  (syntax-rules ()
    ((for element in list body ...)
     (map (lambda (element) body ...) list))))

(for1 i in (iota 10) (format #f "~:a" i))
$8 = ("0" "1" "2" "3" "4" "5" "6" "7" "8" "9")

This works, but produces the same output if I switch 'in' for something else
So put in and alternatives int he keywords

(define-syntax for1
  (syntax-rules (in as)
    ((for element in list body ...)
     (map (lambda (element) body ...) list))
    ((for list as element body ...)
     (map (lambda (element) body ...) list))))

OR 

(define-syntax for2
  (syntax-rules (is as)
    ((for element in list body ...)
     (map (lambda (element) body ...) list))
    ((for list as element body ...)
     (for element in list body ...))))

Nice -- now have basic understanding
Now do the main doc

Syntax-rules
Syntax: syntax-rules literals (pattern template) ...
 Create a syntax transformer that will rewrite an expression using the rules embodied in the pattern and template clauses
A sytnax-rules macro consists of three parts: the literals (if any), the pattersna and as manyy templates as there are patterns

When the syntax expander sees the invocation of a syntax0rules macro, it matche th eexpression aainst the apttersn in order and rewrites the expression using the template from the first matching pattern.
If no pattern matches, a syntax error is signalled

Patterns

Saw some patterns in last section 
 (unless condition exp ...), (my-or exp) 
A pattern is strcuted like the expression that it is to match
Can have nested structure like
 (let ((var val) ...) exp exp* ...)
Pattersn are made of lists, improper lists, vectors, identifiers and datums
Can match a sequence of patterns with ...

Identifiers (like in and as) are called literals if they are present in the syntax rules literals list
 Otherwise called pattern vars

When building up the macro output, expander raplces instances of a patter variable in the template with the matched subexpression

(define-syntax kwote
  (syntax-rules ()
    ((kwote exp)
     (quote exp))))

(define-syntax let1
  (syntax-rules () 
    ((_ (var val) . exps)
     (let ((var val)) . exps))))

Can do more powerful things with syntax0case

syntax-case macros are procedureal syntax transfomers
Syntax:
 syntax-case syntax literals (patter [guard] exp) ...

Match the syntax object syntax against the given patters in order
If a pattern matches return the result of evaluation the associated exp

syntax-case version a bit more verbose
 needs lambda and quoting of syntax, but otherwise similar
macro args are bound to names automatically and no unquoting of syntactic elements is required

 (define-syntax swap! 
   (syntax-rules () 
     ((_ a b) 
      (let ((value a)) 
        (set! a b) 
        (set! b value)))))

 (define-syntax swap! 
   (lambda (stx) 
     (syntax-case stx () 
       ((_ a b) 
        (syntax 
         (let ((value a)) 
           (set! a b) 
           (set! b value))))))) 

For loop macro, need to break hygiene, so use datum->syntax object to define a syntax object representing the exit identifier

By specifying (syntax loop) as an argument, ensure that the exit identifier is inserted into the same syntactive

Still unsure where syntax-case macros are helpful!

It turns out that both Racket and Guile use syntax-case
The main idea is that the macros are syntax to syntax fxns
 Just like defmacro, expept instead of raw S-expressions you're dealing with syntax objects
 Instead of dealin w/ plain symbols, dealing w/ syntax values
  Called identifiers in this case
 That are essentially a symbol and some opaque information that represents the lexical scope for its source

In several syntax case systems this is the only idff from defmacro macros
 But in Racket this applies to everythign 
  identifiers, numbers, other immediate constants, and eve fxn applications
They are all the same S-expression vals, but wrapped w/ extra info

Racket then has
 (syntax-source stx), (syntax-position stx) (syntax-line stx)
 (syntax-column stx)

 (syntax-e stx) -- takes syntax value and returns the value that it wraps
 (syntax->datum stx) -- takes syntax val and returns the plain S-expression that it holds
   done by recursive uses of syntax-e

 (syntax->list stx) -- same as above but returns list
 (syntax-property stx prop) -- return s the given property value

Scheme Procedure: identifier? syntax-object
Returns #t if syntax-object is an identifier, or #f otherwise

(define-syntax add1!
  (lambda (x)
    (syntax-case x ()
      ((_ var) (identifier? #'var)
      #'(set! var (add1 var))))))

Scheme IO

All input and output operation are performed through ports
port is a pointer into a stream of chars (typically a file)
 an opening through which programs
An input port often points to a finite stream -- an input file stored on disk
If one of the input operations (read, read-char, or peek-char) is asked to read froma  port that has reached the end of a finite stream, it returns a special eof object
The predicate eof-object? may be used to determine if an object returned is an eof object
